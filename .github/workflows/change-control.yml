name: ðŸš€ Change Control & Documentation

on:
  pull_request:
    branches:
      - main
      - master
    types: [opened, edited, synchronize, reopened, ready_for_review]

# PermissÃµes necessÃ¡rias
permissions:
  contents: write
  pull-requests: read
  issues: read

jobs:
  generate-documentation:
    runs-on: ubuntu-latest
    steps:
      - name: ðŸ“¥ Checkout do cÃ³digo
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ðŸ” Validar ticket GLPI
        id: validate-ticket
        run: |
          PR_TITLE="${{ github.event.pull_request.title }}"
          PR_BODY="${{ github.event.pull_request.body }}"
          
          # Extrai o primeiro ticket GLPI encontrado
          TICKET=$(echo "$PR_TITLE $PR_BODY" | grep -oE "GLPI-[0-9]+" | head -n 1 || echo "")
          
          if [ -z "$TICKET" ]; then
            echo "âŒ ERRO: O PR deve conter um ticket GLPI-XXXX no tÃ­tulo ou descriÃ§Ã£o."
            exit 1
          fi
          
          echo "ticket=$TICKET" >> $GITHUB_OUTPUT
          echo "âœ… Ticket encontrado: $TICKET"

      - name: ðŸ“‹ Validar campos obrigatÃ³rios
        run: |
          BODY="${{ github.event.pull_request.body }}"
          
          # FunÃ§Ã£o para verificar seÃ§Ã£o
          check_section() {
            local section="$1"
            if ! echo "$BODY" | grep -iE "^###?[[:space:]]*$section" > /dev/null; then
              echo "âŒ ERRO: SeÃ§Ã£o '$section' Ã© obrigatÃ³ria no PR."
              exit 1
            fi
          }
          
          check_section "Como validar"
          check_section "Rollback"
          check_section "Impacto"
          
          echo "âœ… Todos os campos obrigatÃ³rios estÃ£o presentes"

      - name: ðŸ“Š Extrair metadados da release
        id: meta
        run: |
          # Datas
          DATE=$(date +%Y-%m-%d)
          YEAR=$(date +%Y)
          MONTH=$(date +%m)
          TIMESTAMP=$(date +%s)
          
          # SHAs
          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"
          REPO="${{ github.repository }}"
          
          # Determinar versÃ£o baseada no histÃ³rico
          if [ -f CHANGELOG.md ]; then
            # Extrai a Ãºltima versÃ£o do changelog
            LAST_VERSION=$(grep -m 1 -oE '## \[v[0-9]+\.[0-9]+\.[0-9]+\]' CHANGELOG.md | sed -E 's/## \[(v[0-9]+\.[0-9]+\.[0-9]+)\]/\1/')
          fi
          
          if [ -z "$LAST_VERSION" ]; then
            # Primeira release
            MAJOR="0"
            MINOR="1"
            PATCH="0"
          else
            # Incrementa patch automaticamente
            MAJOR=$(echo "$LAST_VERSION" | sed -E 's/v([0-9]+)\.([0-9]+)\.([0-9]+)/\1/')
            MINOR=$(echo "$LAST_VERSION" | sed -E 's/v([0-9]+)\.([0-9]+)\.([0-9]+)/\2/')
            PATCH=$(echo "$LAST_VERSION" | sed -E 's/v([0-9]+)\.([0-9]+)\.([0-9]+)/\3/')
            PATCH=$((PATCH + 1))
          fi
          
          NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          PREV_VERSION="${LAST_VERSION:-N/A}"
          
          # Release name
          RELEASE_NAME="Release ${NEW_VERSION} - ${{ github.event.pull_request.title }}"
          
          echo "date=$DATE" >> $GITHUB_OUTPUT
          echo "year=$YEAR" >> $GITHUB_OUTPUT
          echo "month=$MONTH" >> $GITHUB_OUTPUT
          echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT
          echo "base_sha=$BASE_SHA" >> $GITHUB_OUTPUT
          echo "head_sha=$HEAD_SHA" >> $GITHUB_OUTPUT
          echo "repo=$REPO" >> $GITHUB_OUTPUT
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "prev_version=$PREV_VERSION" >> $GITHUB_OUTPUT
          echo "release_name=$RELEASE_NAME" >> $GITHUB_OUTPUT
          
          echo "âœ… Metadados gerados: $NEW_VERSION"

      - name: ðŸ‘¥ Coletar aprovaÃ§Ãµes
        id: reviews
        run: |
          API_URL="https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/reviews"
          
          REVIEWS=$(curl -sS \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "$API_URL")
          
          # Aprovadores Ãºnicos
          APPROVED_BY_JSON=$(echo "$REVIEWS" | jq -c '[.[] | select(.state == "APPROVED") | .user.login] | unique')
          APPROVED_COUNT=$(echo "$APPROVED_BY_JSON" | jq 'length')
          
          # Formato CSV para texto
          if [ "$APPROVED_COUNT" -eq 0 ]; then
            APPROVED_BY_CSV="Aguardando aprovaÃ§Ãµes"
            APPROVED_BY_JSON='[]'
          else
            APPROVED_BY_CSV=$(echo "$APPROVED_BY_JSON" | jq -r 'join(", ")')
          fi
          
          echo "approved_by_json=$APPROVED_BY_JSON" >> $GITHUB_OUTPUT
          echo "approved_by_csv=$APPROVED_BY_CSV" >> $GITHUB_OUTPUT
          echo "approved_count=$APPROVED_COUNT" >> $GITHUB_OUTPUT
          
          echo "âœ… Aprovadores: $APPROVED_BY_CSV"

      - name: ðŸ”§ Analisar alteraÃ§Ãµes de cÃ³digo
        id: code-analysis
        run: |
          BASE_SHA="${{ steps.meta.outputs.base_sha }}"
          HEAD_SHA="${{ steps.meta.outputs.head_sha }}"
          
          # Arquivos alterados
          CHANGED_FILES=$(git diff --name-only "$BASE_SHA" "$HEAD_SHA" | sort -u)
          FILE_COUNT=$(echo "$CHANGED_FILES" | wc -l)
          
          # EstatÃ­sticas do diff
          DIFF_STATS=$(git diff --shortstat "$BASE_SHA" "$HEAD_SHA")
          [ -z "$DIFF_STATS" ] && DIFF_STATS="0 files changed"
          
          # Commits
          COMMITS=$(git log --pretty=format:"%h - %s (%an)" "$BASE_SHA..$HEAD_SHA")
          COMMIT_COUNT=$(git rev-list --count "$BASE_SHA..$HEAD_SHA")
          
          # AnÃ¡lise de mÃ©todos/funÃ§Ãµes
          METHODS_ANALYSIS=$(git diff -U0 "$BASE_SHA" "$HEAD_SHA" | grep -E '^\+.*(function|def|class|const|let|var|async|=>)' | sed 's/^+//' | grep -v '^\s*$' | head -20)
          METHOD_COUNT=$(echo "$METHODS_ANALYSIS" | grep -v '^\s*$' | wc -l)
          
          # Linguagens detectadas
          LANGUAGES=$(git ls-files | grep -v '^docs/' | sed 's/.*\.//' | sort -u | tr '\n' ', ' | sed 's/, $//')
          
          # JSON dos arquivos
          FILES_JSON=$(echo "$CHANGED_FILES" | jq -R -s -c 'split("\n") | map(select(length > 0))')
          
          # EstatÃ­sticas por arquivo
          FILE_STATS=$(git diff --numstat "$BASE_SHA" "$HEAD_SHA" | awk '{print $1":"$2":"$3}' | tr '\n' '|')
          
          echo "changed_files_json=$FILES_JSON" >> $GITHUB_OUTPUT
          echo "file_count=$FILE_COUNT" >> $GITHUB_OUTPUT
          echo "diff_stats=$DIFF_STATS" >> $GITHUB_OUTPUT
          echo "commit_count=$COMMIT_COUNT" >> $GITHUB_OUTPUT
          echo "method_count=$METHOD_COUNT" >> $GITHUB_OUTPUT
          echo "languages=$LANGUAGES" >> $GITHUB_OUTPUT
          echo "file_stats=$FILE_STATS" >> $GITHUB_OUTPUT
          
          # Salvar para uso posterior
          echo "$COMMITS" > commits.txt
          echo "$METHODS_ANALYSIS" > methods.txt
          
          echo "âœ… AnÃ¡lise de cÃ³digo concluÃ­da: $FILE_COUNT arquivos, $COMMIT_COUNT commits"

      - name: ðŸ“ Extrair seÃ§Ãµes do PR
        id: extract-sections
        run: |
          PR_BODY="${{ github.event.pull_request.body }}"
          
          # FunÃ§Ã£o para extrair seÃ§Ã£o markdown
          extract_section() {
            local section="$1"
            echo "$PR_BODY" | awk -v title="$section" '
              BEGIN {found=0; IGNORECASE=1}
              tolower($0) ~ "^#+[[:space:]]*" tolower(title) "[[:space:]]*$" {found=1; next}
              found && /^#+[[:space:]]/ {exit}
              found {print}
            ' | sed '/^$/d' | head -20
          }
          
          # Extrair seÃ§Ãµes
          HOW_TO_VALIDATE=$(extract_section "Como validar" | head -10)
          IMPACT=$(extract_section "Impacto" | head -10)
          ROLLBACK=$(extract_section "Rollback" | head -10)
          
          # Fallbacks
          [ -z "$HOW_TO_VALIDATE" ] && HOW_TO_VALIDATE="*Nenhum roteiro de validaÃ§Ã£o fornecido. Recomenda-se adicionar casos de teste.*"
          [ -z "$IMPACT" ] && IMPACT="*Impacto nÃ£o descrito. Favor documentar o impacto desta mudanÃ§a.*"
          [ -z "$ROLLBACK" ] && ROLLBACK="*EstratÃ©gia de rollback nÃ£o documentada. Recomenda-se definir plano de reversÃ£o.*"
          
          # Salvar em arquivos
          echo "$HOW_TO_VALIDATE" > how_to_validate.txt
          echo "$IMPACT" > impact.txt
          echo "$ROLLBACK" > rollback.txt
          
          echo "âœ… SeÃ§Ãµes extraÃ­das com sucesso"

      - name: ðŸŽ¨ Gerar documentaÃ§Ã£o markdown
        run: |
          # ConfiguraÃ§Ãµes
          YEAR="${{ steps.meta.outputs.year }}"
          MONTH="${{ steps.meta.outputs.month }}"
          TICKET="${{ steps.validate-ticket.outputs.ticket }}"
          NEW_VERSION="${{ steps.meta.outputs.new_version }}"
          DATE="${{ steps.meta.outputs.date }}"
          REPO="${{ steps.meta.outputs.repo }}"
          BASE_SHA="${{ steps.meta.outputs.base_sha }}"
          HEAD_SHA="${{ steps.meta.outputs.head_sha }}"
          
          # DiretÃ³rio de saÃ­da
          DOC_DIR="docs/releases/$YEAR/$MONTH"
          mkdir -p "$DOC_DIR"
          DOC_FILE="$DOC_DIR/${TICKET}.md"
          
          # Ler arquivos temporÃ¡rios
          HOW_TO_VALIDATE=$(cat how_to_validate.txt)
          IMPACT=$(cat impact.txt)
          ROLLBACK=$(cat rollback.txt)
          COMMITS=$(cat commits.txt)
          METHODS=$(cat methods.txt)
          CHANGED_FILES="${{ steps.code-analysis.outputs.changed_files_json }}"
          
          # MÃ©todos formatados
          METHODS_FORMATTED=$(echo "$METHODS" | sed 's/^/- /')
          [ -z "$METHODS_FORMATTED" ] && METHODS_FORMATTED="- Nenhum mÃ©todo/funÃ§Ã£o novo identificado"
          
          # Commits formatados
          COMMITS_FORMATTED=$(echo "$COMMITS" | sed 's/^/- /')
          [ -z "$COMMITS_FORMATTED" ] && COMMITS_FORMATTED="- Nenhum commit no intervalo"
          
          # Arquivos formatados
          FILES_FORMATTED=$(echo "$CHANGED_FILES" | jq -r '.[]' | sed 's/^/- ðŸ“„ /')
          [ -z "$FILES_FORMATTED" ] && FILES_FORMATTED="- Nenhum arquivo alterado"
          
          # Gerar documento markdown com template melhorado
          cat << EOF | sed 's/^          //' > "$DOC_FILE"
          # $TICKET

          ## ðŸ“¦ Release $NEW_VERSION

          **Data:** $DATE  
          **Autor:** ${{ github.actor }}  
          **Aprovadores:** ${{ steps.reviews.outputs.approved_by_csv }}  
          **Pull Request:** [#${{ github.event.pull_request.number }}](${{ github.event.pull_request.html_url }})

          ---

          ## ðŸ“‹ Resumo da Release

          **TÃ­tulo:** ${{ github.event.pull_request.title }}

          ### Arquivos Alterados (${{ steps.code-analysis.outputs.file_count }})

          $FILES_FORMATTED

          ### EstatÃ­sticas de CÃ³digo

          - **Commits:** ${{ steps.code-analysis.outputs.commit_count }}
          - **MÃ©todos/FunÃ§Ãµes:** ${{ steps.code-analysis.outputs.method_count }}
          - **Linguagens:** ${{ steps.code-analysis.outputs.languages }}
          - **Resumo:** ${{ steps.code-analysis.outputs.diff_stats }}

          ---

          ## ðŸ” Como Validar

          $HOW_TO_VALIDATE

          ---

          ## ðŸ’¥ Impacto

          $IMPACT

          ---

          ## â†©ï¸ Rollback

          $ROLLBACK

          ---

          ## ðŸ”§ Detalhes TÃ©cnicos

          ### Commits

          $COMMITS_FORMATTED

          ### MÃ©todos/FunÃ§Ãµes Modificadas

          $METHODS_FORMATTED

          ---

          ## ðŸ”— Links Ãšteis

          - **ComparaÃ§Ã£o:** [\`$BASE_SHA...$HEAD_SHA\`](https://github.com/$REPO/compare/$BASE_SHA...$HEAD_SHA)
          - **Commit Base:** [\`$BASE_SHA\`](https://github.com/$REPO/commit/$BASE_SHA)
          - **Commit Head:** [\`$HEAD_SHA\`](https://github.com/$REPO/commit/$HEAD_SHA)
          - **VersÃ£o Anterior:** ${{ steps.meta.outputs.prev_version }}

          ---

          *DocumentaÃ§Ã£o gerada automaticamente em $DATE*
          EOF
          
          echo "âœ… DocumentaÃ§Ã£o gerada: $DOC_FILE"

      - name: ðŸ“š Atualizar CHANGELOG
        run: |
          NEW_VERSION="${{ steps.meta.outputs.new_version }}"
          DATE="${{ steps.meta.outputs.date }}"
          TICKET="${{ steps.validate-ticket.outputs.ticket }}"
          REPO="${{ steps.meta.outputs.repo }}"
          BASE_SHA="${{ steps.meta.outputs.base_sha }}"
          HEAD_SHA="${{ steps.meta.outputs.head_sha }}"
          PR_NUMBER="${{ github.event.pull_request.number }}"
          PR_TITLE="${{ github.event.pull_request.title }}"
          
          # Criar CHANGELOG se nÃ£o existir
          if [ ! -f CHANGELOG.md ]; then
            echo "# Changelog" > CHANGELOG.md
            echo "" >> CHANGELOG.md
            echo "Todas as versÃµes notÃ¡veis deste projeto serÃ£o documentadas neste arquivo." >> CHANGELOG.md
            echo "" >> CHANGELOG.md
          fi
          
          # Verificar se versÃ£o jÃ¡ existe
          if grep -q "^## \[$NEW_VERSION\]" CHANGELOG.md; then
            echo "âš ï¸ VersÃ£o $NEW_VERSION jÃ¡ registrada no changelog"
          else
            # Criar entrada do changelog
            TEMP_CHANGELOG=$(mktemp)
            
            {
              echo "## [$NEW_VERSION] - $DATE"
              echo ""
              echo "### $PR_TITLE"
              echo ""
              echo "#### ðŸŽ« Ticket"
              echo "- $TICKET"
              echo ""
              echo "#### ðŸ“Š EstatÃ­sticas"
              echo "- Arquivos alterados: ${{ steps.code-analysis.outputs.file_count }}"
              echo "- Commits: ${{ steps.code-analysis.outputs.commit_count }}"
              echo "- MÃ©todos/FunÃ§Ãµes: ${{ steps.code-analysis.outputs.method_count }}"
              echo ""
              echo "#### âœ… AprovaÃ§Ãµes"
              echo "- Aprovadores: ${{ steps.reviews.outputs.approved_by_csv }}"
              echo ""
              echo "#### ðŸ”— Links"
              echo "- Pull Request: [#$PR_NUMBER](${{ github.event.pull_request.html_url }})"
              echo "- ComparaÃ§Ã£o: [$BASE_SHA...$HEAD_SHA](https://github.com/$REPO/compare/$BASE_SHA...$HEAD_SHA)"
              echo ""
            } > "$TEMP_CHANGELOG"
            
            # Inserir no inÃ­cio do arquivo (apÃ³s o cabeÃ§alho)
            awk '
              NR==1 {print; print ""; next}
              /^#/ && !done {system("cat '$TEMP_CHANGELOG'"); done=1}
              {print}
            ' CHANGELOG.md > CHANGELOG.tmp
            
            mv CHANGELOG.tmp CHANGELOG.md
            rm "$TEMP_CHANGELOG"
            
            echo "âœ… CHANGELOG atualizado com versÃ£o $NEW_VERSION"
          fi

      - name: ðŸ”„ Gerar JSON de codeChanges
        id: code-changes
        run: |
          BASE_SHA="${{ steps.meta.outputs.base_sha }}"
          HEAD_SHA="${{ steps.meta.outputs.head_sha }}"
          export BASE_SHA
          export HEAD_SHA
          
            # Analisar mudanÃ§as linha a linha
            cat << 'PYTHON_SCRIPT' | sed 's/^          //' > code_changes_script.py
            import json
            import os
            import re
            import subprocess

            base_sha = os.environ.get('BASE_SHA')
            head_sha = os.environ.get('HEAD_SHA')

            try:
              diff = subprocess.check_output(
                ['git', 'diff', '-U0', base_sha, head_sha],
                text=True,
                stderr=subprocess.DEVNULL
              )
            except subprocess.CalledProcessError:
              diff = ''

            changes = []
            current_file = None
            current_line = None

            method_patterns = [
              r'^\+\s*(function\s+\w+\s*\()',
              r'^\+\s*(const\s+\w+\s*=\s*\([^)]*\)\s*=>)',
              r'^\+\s*(let\s+\w+\s*=\s*\([^)]*\)\s*=>)',
              r'^\+\s*(class\s+\w+)',
              r'^\+\s*(def\s+\w+\s*\()',
              r'^\+\s*(\w+\s*=\s*function\s*\()',
              r'^\+\s*(async\s+function\s+\w+\s*\()',
              r'^\+\s*(async\s+\w+\s*=\s*\([^)]*\)\s*=>)',
              r'^\+\s*(\w+\s*:\s*function\s*\()',
              r'^\+\s*(\w+\s*\([^)]*\)\s*{)',
            ]

            line_pattern = re.compile(r'^@@ -\d+(?:,\d+)? \+(\d+)(?:,(\d+))? @@')

            for line in diff.split('\n'):
              if line.startswith('+++ b/'):
                current_file = line[6:]
                continue

              line_match = line_pattern.match(line)
              if line_match:
                current_line = int(line_match.group(1))
                continue

              if line.startswith('+') and not line.startswith('+++'):
                if current_line is None or not current_file:
                  continue

                code = line[1:].rstrip()
                if not code.strip():
                  current_line += 1
                  continue

                change_type = 'AlteraÃ§Ã£o'
                for pattern in method_patterns:
                  if re.search(pattern, code, re.IGNORECASE):
                    if 'class' in pattern:
                      change_type = 'Classe'
                    else:
                      change_type = 'FunÃ§Ã£o/MÃ©todo'
                    break

                changes.append({
                  'type': change_type,
                  'file': current_file,
                  'lineStart': current_line,
                  'lineEnd': current_line,
                  'code': code.strip(),
                  'commit': head_sha,
                  'language': os.path.splitext(current_file)[1][1:] or 'unknown'
                })
                current_line += 1

            changes = changes[:50]
            print(json.dumps(changes, ensure_ascii=False, indent=2))
            PYTHON_SCRIPT

            python3 code_changes_script.py > code_changes.json
            rm -f code_changes_script.py
          
          echo "âœ… Code changes JSON gerado"

      - name: ðŸ“Š Gerar releases.json para front-end
        run: |
          # ConfiguraÃ§Ãµes
          NEW_VERSION="${{ steps.meta.outputs.new_version }}"
          DATE="${{ steps.meta.outputs.date }}"
          TIMESTAMP="${{ steps.meta.outputs.timestamp }}"
          TICKET="${{ steps.validate-ticket.outputs.ticket }}"
          REPO="${{ steps.meta.outputs.repo }}"
          BASE_SHA="${{ steps.meta.outputs.base_sha }}"
          HEAD_SHA="${{ steps.meta.outputs.head_sha }}"
          YEAR="${{ steps.meta.outputs.year }}"
          MONTH="${{ steps.meta.outputs.month }}"
          PREV_VERSION="${{ steps.meta.outputs.prev_version }}"
          
          # JSONs
          APPROVED_BY_JSON="${{ steps.reviews.outputs.approved_by_json }}"
          CHANGED_FILES_JSON="${{ steps.code-analysis.outputs.changed_files_json }}"
          CODE_CHANGES_JSON=$(cat code_changes.json)
          
          # Links dos arquivos
          FILE_LINKS_JSON=$(echo "$CHANGED_FILES_JSON" | jq -c --arg repo "$REPO" --arg sha "$HEAD_SHA" '
            map({
              path: .,
              url: ("https://github.com/" + $repo + "/blob/" + $sha + "/" + .)
            })
          ')
          
          # Paths dos documentos
          DOC_PATH="docs/releases/$YEAR/$MONTH/${TICKET}.md"
          DOC_URL="https://github.com/$REPO/blob/$HEAD_SHA/$DOC_PATH"
          CHANGELOG_PATH="CHANGELOG.md"
          CHANGELOG_URL="https://github.com/$REPO/blob/$HEAD_SHA/$CHANGELOG_PATH"
          
          # Criar diretÃ³rio docs se nÃ£o existir
          mkdir -p docs
          
          # Arquivo de releases
          RELEASES_FILE="docs/releases.json"
          
          # Criar se nÃ£o existir
          if [ ! -f "$RELEASES_FILE" ]; then
            echo '{"releases":[], "metadata":{"lastUpdated":"", "totalReleases":0}}' > "$RELEASES_FILE"
          fi
          
          # Nova release
          NEW_RELEASE=$(jq -n \
            --arg version "$NEW_VERSION" \
            --arg date "$DATE" \
            --arg timestamp "$TIMESTAMP" \
            --arg ticket "$TICKET" \
            --arg author "${{ github.actor }}" \
            --argjson approvedBy "$APPROVED_BY_JSON" \
            --arg prNumber "${{ github.event.pull_request.number }}" \
            --arg prTitle "${{ github.event.pull_request.title }}" \
            --arg prUrl "${{ github.event.pull_request.html_url }}" \
            --arg baseSha "$BASE_SHA" \
            --arg headSha "$HEAD_SHA" \
            --arg compareUrl "https://github.com/$REPO/compare/$BASE_SHA...$HEAD_SHA" \
            --arg previousVersion "$PREV_VERSION" \
            --arg changeLogPath "$CHANGELOG_PATH" \
            --arg changeLogUrl "$CHANGELOG_URL" \
            --arg releaseDocPath "$DOC_PATH" \
            --arg releaseDocUrl "$DOC_URL" \
            --argjson changedFiles "$CHANGED_FILES_JSON" \
            --argjson fileLinks "$FILE_LINKS_JSON" \
            --argjson codeChanges "$CODE_CHANGES_JSON" \
            --arg fileCount "${{ steps.code-analysis.outputs.file_count }}" \
            --arg commitCount "${{ steps.code-analysis.outputs.commit_count }}" \
            --arg methodCount "${{ steps.code-analysis.outputs.method_count }}" \
            '{
              version: $version,
              date: $date,
              timestamp: $timestamp,
              ticket: $ticket,
              author: $author,
              approvedBy: $approvedBy,
              pr: {
                number: $prNumber,
                title: $prTitle,
                url: $prUrl
              },
              commits: {
                base: $baseSha,
                head: $headSha,
                compareUrl: $compareUrl,
                previousVersion: $previousVersion
              },
              docs: {
                changeLogPath: $changeLogPath,
                changeLogUrl: $changeLogUrl,
                releaseDocPath: $releaseDocPath,
                releaseDocUrl: $releaseDocUrl
              },
              stats: {
                fileCount: $fileCount,
                commitCount: $commitCount,
                methodCount: $methodCount
              },
              changedFiles: $changedFiles,
              fileLinks: $fileLinks,
              codeChanges: $codeChanges
            }')
          
          # Atualizar arquivo
          TMP_FILE=$(mktemp)
          
          jq --argjson newRelease "$NEW_RELEASE" --arg timestamp "$TIMESTAMP" '
            .metadata.lastUpdated = $timestamp |
            .metadata.totalReleases = (.releases | length) + 1 |
            .releases = [$newRelease] + (.releases | map(select(.version != $newRelease.version))) |
            .releases = (.releases | sort_by(.timestamp) | reverse)
          ' "$RELEASES_FILE" > "$TMP_FILE"
          
          mv "$TMP_FILE" "$RELEASES_FILE"
          
          echo "âœ… releases.json atualizado com versÃ£o $NEW_VERSION"

      - name: ðŸ“± Gerar preview da release (opcional)
        if: github.event.pull_request.draft == false
        run: |
          # Criar preview da release para comentÃ¡rio no PR
          PREVIEW_FILE=$(mktemp)
          
          cat << EOF | sed 's/^          //' > "$PREVIEW_FILE"
          ## ðŸš€ Release ${{ steps.meta.outputs.new_version }} - Preview

          **ðŸ“‹ Resumo da Release**

          | Item | Detalhe |
          |------|---------|
          | VersÃ£o | ${{ steps.meta.outputs.new_version }} |
          | Ticket | ${{ steps.validate-ticket.outputs.ticket }} |
          | Autor | ${{ github.actor }} |
          | Aprovadores | ${{ steps.reviews.outputs.approved_by_csv }} |
          | Arquivos | ${{ steps.code-analysis.outputs.file_count }} |
          | Commits | ${{ steps.code-analysis.outputs.commit_count }} |

          **ðŸ“Š DocumentaÃ§Ã£o Gerada**

          - ðŸ“„ [Documento da Release](https://github.com/${{ github.repository }}/blob/${{ steps.meta.outputs.head_sha }}/docs/releases/${{ steps.meta.outputs.year }}/${{ steps.meta.outputs.month }}/${{ steps.validate-ticket.outputs.ticket }}.md)
          - ðŸ“š [CHANGELOG](https://github.com/${{ github.repository }}/blob/${{ steps.meta.outputs.head_sha }}/CHANGELOG.md)
          - ðŸ—‚ï¸ [CatÃ¡logo de Releases](https://github.com/${{ github.repository }}/blob/${{ steps.meta.outputs.head_sha }}/docs/releases.json)

          **âš¡ Preview no Portal**
          > Assim que mergeado, a release estarÃ¡ disponÃ­vel no portal de releases.
          EOF
          
          # Comentar no PR (opcional - descomentar se quiser)
          # gh pr comment ${{ github.event.pull_request.number }} --body-file "$PREVIEW_FILE"
          
          echo "âœ… Preview gerado"

      - name: âœ… Commit e push das mudanÃ§as
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Adicionar arquivos
          git add docs/releases/
          git add docs/releases.json
          git add CHANGELOG.md
          
          # Verificar se hÃ¡ mudanÃ§as para commitar
          if git diff --staged --quiet; then
            echo "â„¹ï¸ Nenhuma mudanÃ§a para commitar"
          else
            git commit -m "docs: release ${{ steps.meta.outputs.new_version }} - ${{ steps.validate-ticket.outputs.ticket }}"
            
            # Pull com rebase para evitar conflitos
            git pull --rebase origin ${{ github.event.pull_request.head.ref }}
            
            # Push
            git push origin HEAD:${{ github.event.pull_request.head.ref }}
            
            echo "âœ… MudanÃ§as commitadas e enviadas"
          fi

      - name: ðŸ“¢ SumÃ¡rio da execuÃ§Ã£o
        if: always()
        run: |
          echo "## ðŸ“Š Resumo da DocumentaÃ§Ã£o Gerada" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Detalhe |" >> $GITHUB_STEP_SUMMARY
          echo "|------|---------|" >> $GITHUB_STEP_SUMMARY
          echo "| **VersÃ£o** | ${{ steps.meta.outputs.new_version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Ticket** | ${{ steps.validate-ticket.outputs.ticket }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Autor** | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Aprovadores** | ${{ steps.reviews.outputs.approved_by_csv }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Arquivos** | ${{ steps.code-analysis.outputs.file_count }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Commits** | ${{ steps.code-analysis.outputs.commit_count }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **MÃ©todos** | ${{ steps.code-analysis.outputs.method_count }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“ Arquivos Gerados" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ“„ [Documento da Release](https://github.com/${{ github.repository }}/blob/${{ steps.meta.outputs.head_sha }}/docs/releases/${{ steps.meta.outputs.year }}/${{ steps.meta.outputs.month }}/${{ steps.validate-ticket.outputs.ticket }}.md)" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ“š [CHANGELOG](https://github.com/${{ github.repository }}/blob/${{ steps.meta.outputs.head_sha }}/CHANGELOG.md)" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ—‚ï¸ [CatÃ¡logo de Releases](https://github.com/${{ github.repository }}/blob/${{ steps.meta.outputs.head_sha }}/docs/releases.json)" >> $GITHUB_STEP_SUMMARY
